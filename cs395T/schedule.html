<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Schedule — CS 395T: Principles of Learned Systems</title>
  <meta name="description" content="Course schedule for CS 395T: Principles of Learned Systems." />
  <style>
    :root {
      --text: #111;
      --muted: #555;
      --bg: #fff;
      --border: #e5e7eb;
      --border2: #f0f2f5;
      --link: #0b57d0;
      --maxw: 1100px;
      --chip: #f6f7f9;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--text);
      background: var(--bg);
      line-height: 1.45;
    }
    .wrap { max-width: var(--maxw); margin: 0 auto; padding: 28px 18px 70px; }
    header { margin-bottom: 18px; }
    .course-title { font-size: 28px; font-weight: 700; margin: 0 0 4px; }
    .term { color: var(--muted); margin: 0 0 14px; }
    nav {
      display: flex; gap: 14px; flex-wrap: wrap;
      padding: 10px 0 0;
      border-top: 1px solid var(--border);
    }
    nav a { color: var(--link); text-decoration: none; }
    nav a:hover { text-decoration: underline; }
    h1 { font-size: 22px; margin: 22px 0 10px; }
    a { color: var(--link); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .table-wrap {
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    thead th {
      text-align: left;
      background: #fbfbfc;
      border-bottom: 1px solid var(--border);
      padding: 12px 12px;
      font-weight: 700;
    }
    tbody td {
      vertical-align: top;
      border-bottom: 1px solid var(--border2);
      padding: 12px 12px;
    }
    tbody tr:last-child td { border-bottom: none; }
    tbody tr.topic-end td { border-bottom: 2px solid var(--border); }
    td.topic-cell-end { border-bottom: 2px solid var(--border) !important; }
    /* Styling for same-date paper rows */
    tbody tr.same-date-first td:not([rowspan]) {
      padding-bottom: 2px !important;
      border-bottom: none !important;
    }
    tbody tr.same-date td {
      padding-top: 2px !important;
      padding-bottom: 2px !important;
      border-bottom: none !important;
    }
    /* Restore border for the last row in same-date group */
    tbody tr.same-date-last td {
      border-bottom: 1px solid var(--border2) !important;
      padding-bottom: 12px !important;
    }
    .muted { color: var(--muted); }
    .links a { display: inline-block; margin-right: 10px; }
    .topic { font-weight: 600; }
    .small { font-size: 12px; }
    @media (max-width: 860px) {
      thead { display: none; }
      table, tbody, tr, td { display: block; width: 100%; }
      tbody tr { border-bottom: 1px solid var(--border); }
      tbody td { border: none; padding: 10px 12px; }
      tbody td[data-label]::before {
        content: attr(data-label);
        display: block;
        font-weight: 700;
        margin-bottom: 4px;
      }
    }
    /* Center the merged Topic cells vertically */
    td[rowspan] { 
      vertical-align: middle; 
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="course-title">CS 395T: Principles of Learned Systems</div>
      <p class="term">Spring 2026</p>
      <nav>
        <a href="./index.html">Home</a>
        <a href="./schedule.html">Schedule</a>
      </nav>
    </header>

    <main>
      <h1>Course Schedule</h1>

      <div class="table-wrap">
        <table aria-label="Course schedule table">
          <thead>
            <tr>
              <th style="width: 200px;">Topic</th>
              <th style="width: 130px;">Date</th>
              <th>Paper</th>
              <th style="width: 100px;">Slides</th>
              <th style="width: 100px;">Notes</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </main>
  </div>

<script>
  // ====== EDIT THIS DATA ======
  // Rule: put topic only on the FIRST lecture of a group.
  // For continuation rows, set topic: "" (empty string).
  const LECTURES = [
    { date: "Jan 13", topic: "Course Intro + overview", paper: { title: "How to Read a Paper", url: "http://ccr.sigcomm.org/online/files/p83-keshavA.pdf" }, slides: null, notes: null },

    { date: "Jan 15", topic: "Need for ML for systems", paper: { title: "Learned Operating Systems", url: "https://cseweb.ucsd.edu/~yiying/LearnedOS-OSR19.pdf" }, slides: null, notes: null },
    { date: "Jan 15", topic: "", paper: { title: "Park: An Open Platform for Learning-Augmented Computer Systems", url: "#" }, slides: null, notes: null },
    { date: "Jan 20", topic: "", paper: { title: "Toward ML-centric Cloud Platforms", url: "https://www.microsoft.com/en-us/research/wp-content/uploads/2020/01/CACM20-produced.pdf" }, slides: null, notes: null },

    { date: "Jan 22", topic: "Resource management", paper: { title: "Learning-based Memory Allocation for C++ Server Workloads", url: "https://dl.acm.org/doi/pdf/10.1145/3373376.3378525" }, slides: null, notes: null },
    { date: "Jan 27", topic: "", paper: { title: "Heimdall: Optimizing Storage I/O Admission with Extensive Machine Learning Pipeline", url: "https://dl.acm.org/doi/pdf/10.1145/3689031.3717496" }, slides: null, notes: null },
    { date: "Jan 29", topic: "", paper: { title: "ArtMem: Adaptive Migration in Reinforcement Learning-Enabled Tiered Memory", url: "https://dl.acm.org/doi/epdf/10.1145/3695053.3731001" }, slides: null, notes: null },

    { date: "Feb 3", topic: "LLM/agents for system", paper: { title: "VULCAN: Instance-Optimal Systems Heuristics Through LLM-Driven Search", url: "https://arxiv.org/pdf/2512.25065" }, slides: null, notes: null },
    { date: "Feb 5", topic: "", paper: { title: "KernelEvolve: Scaling Agentic Kernel Coding for Heterogeneous AI Accelerators at Meta", url: "https://arxiv.org/pdf/2512.23236" }, slides: null, notes: null },
    { date: "Feb 10", topic: "", paper: { title: "Automatic Root Cause Analysis via LLMs for Cloud Incidents", url: "https://arxiv.org/pdf/2305.15778" }, slides: null, notes: null },

    { date: "Feb 12", topic: "Databases", paper: { title: "The Case for Learned Index Structures", url: "https://dl.acm.org/doi/pdf/10.1145/3183713.3196909" }, slides: null, notes: null },
    { date: "Feb 17", topic: "", paper: { title: "From WiscKey to Bourbon: A Learned Index for Log-Structured Merge Trees", url: "https://www.usenix.org/system/files/osdi20-dai_0.pdf" }, slides: null, notes: null },
    { date: "Feb 19", topic: "", paper: { title: "openGauss: an autonomous database system", url: "https://dl.acm.org/doi/pdf/10.14778/3476311.3476380" }, slides: null, notes: null },

    { date: "Feb 24", topic: "Datacenters", paper: { title: "Learning scheduling algorithms for data processing clusters", url: "https://dl.acm.org/doi/pdf/10.1145/3341302.3342080" }, slides: null, notes: null },
    { date: "Feb 26", topic: "", paper: { title: "TUNA: Tuning Unstable and Noisy Cloud Applications", url: "https://dl.acm.org/doi/pdf/10.1145/3689031.3717480" }, slides: null, notes: null },
    { date: "Mar 3", topic: "", paper: { title: "OPPerTune: Post-Deployment Configuration Tuning of Services Made Easy", url: "https://www.usenix.org/system/files/nsdi24-somashekar.pdf" }, slides: null, notes: null },

    { date: "Mar 5", topic: "Resource management 2", paper: { title: "Darwin: Flexible Learning-based CDN Caching", url: "https://dl.acm.org/doi/pdf/10.1145/3603269.3604863" }, slides: null, notes: null },
    { date: "Mar 10", topic: "", paper: { title: "Learning Memory Access Patterns", url: "https://proceedings.mlr.press/v80/hashemi18a/hashemi18a.pdf" }, slides: null, notes: null },
    { date: "Mar 12", topic: "", paper: { title: "Classic Meets Modern: a Pragmatic Learning-Based Congestion Control for the Internet", url: "https://dl.acm.org/doi/pdf/10.1145/3387514.3405892" }, slides: null, notes: null },

    { date: "Mar 17", topic: "Spring Break", paper: null, slides: null, notes: null },
    { date: "Mar 19", topic: "", paper: null, slides: null, notes: null },

    { date: "Mar 24", topic: "ML Deployment", paper: { title: "Towards a Machine Learning-Assisted Kernel with LAKE", url: "https://dl.acm.org/doi/pdf/10.1145/3575693.3575697" }, slides: null, notes: null },
    { date: "Mar 26", topic: "", paper: { title: "Murphy: Performance Diagnosis of Distributed Cloud Applications", url: "https://dl.acm.org/doi/pdf/10.1145/3603269.3604877" }, slides: null, notes: null },
    { date: "Mar 31", topic: "", paper: { title: "HALP: Heuristic Aided Learned Preference Eviction Policy for YouTube Content Delivery Network", url: "https://www.usenix.org/system/files/nsdi23-song-zhenyu.pdf" }, slides: null, notes: null },

    { date: "Apr 2", topic: "Robustness", paper: { title: "Galileo", url: "#" }, slides: null, notes: null },
    { date: "Apr 7", topic: "", paper: { title: "C3: Learning Congestion Controllers with Formal Certificates", url: "https://arxiv.org/pdf/2412.10915" }, slides: null, notes: null },

    { date: "Apr 9", topic: "Trace synthesis", paper: { title: "Zoom2Net: Constrained Network Telemetry Imputation", url: "https://dl.acm.org/doi/pdf/10.1145/3651890.3672225" }, slides: null, notes: null },
    { date: "Apr 14", topic: "", paper: { title: "Large Language Models as Realistic Microservice Trace Generators", url: "https://aclanthology.org/2025.emnlp-main.4.pdf" }, slides: null, notes: null },

    { date: "Apr 16", topic: "Simulation", paper: { title: "CausalSim: A Causal Framework for Unbiased Trace-Driven Simulation", url: "https://www.usenix.org/system/files/nsdi23-alomar.pdf" }, slides: null, notes: null },

    { date: "Apr 21", topic: "Project presentations", paper: null, slides: null, notes: null },
    { date: "Apr 23", topic: "", paper: null, slides: null, notes: null },
  ];
  // ===========================

  const rowsEl = document.getElementById("rows");

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function renderPaper(p) {
    if (!p) return "<span class='muted'>—</span>";
    const title = escapeHtml(p.title);
    const url = escapeHtml(p.url || "#");
    return `<a href="${url}" target="_blank" rel="noopener">${title}</a>`;
  }

  function renderLink(linkUrl) {
    if (!linkUrl) return "<span class='muted'>—</span>";
    const url = escapeHtml(linkUrl);
    return `<a href="${url}" target="_blank" rel="noopener">Link</a>`;
  }

  // Compute topic groups so we can set rowspan on the first row of each group.
  function computeGroups(items) {
    const groups = [];
    let current = null;

    for (let i = 0; i < items.length; i++) {
      const lec = items[i];
      const startsNew = (lec.topic && lec.topic.trim().length > 0);

      if (startsNew) {
        current = { topic: lec.topic.trim(), startIndex: i, length: 1 };
        groups.push(current);
      } else {
        // Continuation row: attach to previous group if it exists, else treat as its own empty topic group.
        if (!current) {
          current = { topic: "", startIndex: i, length: 1 };
          groups.push(current);
        } else {
          current.length++;
        }
      }
    }

    // Map start index -> rowspan length + topic
    const byStart = new Map();
    for (const g of groups) byStart.set(g.startIndex, g);
    return byStart;
  }

  // Compute date groups for merging same dates
  function computeDateGroups(items) {
    const byIndex = new Map();
    let i = 0;
    
    while (i < items.length) {
      const currentDate = items[i].date;
      let length = 1;
      
      // Count consecutive rows with the same date
      while (i + length < items.length && items[i + length].date === currentDate) {
        length++;
      }
      
      // Store the group info for ALL rows in the group
      if (length > 1) {
        const groupInfo = { startIndex: i, length: length };
        for (let j = i; j < i + length; j++) {
          byIndex.set(j, groupInfo);
        }
      }
      
      i += length;
    }
    
    return byIndex;
  }

  function render() {
    const groupByStartIndex = computeGroups(LECTURES);
    const dateGroupByStartIndex = computeDateGroups(LECTURES);
    
    console.log('Date groups:', dateGroupByStartIndex); // Debug
    
    // Build a set of indices that are the last row of each topic group
    const topicEndIndices = new Set();
    for (const [startIdx, group] of groupByStartIndex) {
      const lastIdx = startIdx + group.length - 1;
      topicEndIndices.add(lastIdx);
    }

    rowsEl.innerHTML = LECTURES.map((lec, i) => {
      const isTopicEnd = topicEndIndices.has(i);
      
      // Check if this is part of a date group (same date appears multiple times consecutively)
      const dateGroup = dateGroupByStartIndex.get(i);
      const isSameDateRow = dateGroup && dateGroup.length > 1;
      const isFirstOfDateGroup = dateGroup && dateGroup.startIndex === i;
      const isLastOfDateGroup = dateGroup && dateGroup.startIndex + dateGroup.length - 1 === i;
      
      console.log(`Row ${i}: date=${lec.date}, isSameDateRow=${isSameDateRow}, isFirst=${isFirstOfDateGroup}, isLast=${isLastOfDateGroup}, dateGroup=`, dateGroup); // Debug
      
      // Build class list
      const classes = [];
      if (isTopicEnd) classes.push('topic-end');
      if (isSameDateRow && isFirstOfDateGroup) classes.push('same-date-first');
      if (isSameDateRow && !isFirstOfDateGroup && !isLastOfDateGroup) classes.push('same-date');
      if (isSameDateRow && isLastOfDateGroup && !isFirstOfDateGroup) classes.push('same-date same-date-last');
      const finalTrClass = classes.length > 0 ? ` class="${classes.join(' ')}"` : '';
      
      // Render date cell with rowspan if this starts a date group
      let dateTd;
      if (isFirstOfDateGroup && dateGroup.length > 1) {
        dateTd = `<td data-label="Date" rowspan="${dateGroup.length}">${escapeHtml(lec.date)}</td>`;
      } else if (isSameDateRow && !isFirstOfDateGroup) {
        dateTd = ''; // Omit date cell for continuation rows
      } else {
        dateTd = `<td data-label="Date">${escapeHtml(lec.date)}</td>`;
      }
      
      const paperTd = `<td data-label="Paper">${renderPaper(lec.paper)}</td>`;
      const slidesTd = `<td data-label="Slides">${renderLink(lec.slides)}</td>`;
      const notesTd = `<td data-label="Notes">${renderLink(lec.notes)}</td>`;

      // If this row starts a topic group, render a Topic cell with rowspan.
      const group = groupByStartIndex.get(i);
      if (group) {
        const topicText = group.topic ? escapeHtml(group.topic) : "";
        // Check if THIS group ends at a topic-end index
        const groupLastIdx = i + group.length - 1;
        const isThisGroupEnd = topicEndIndices.has(groupLastIdx);
        const topicCellClass = isThisGroupEnd ? ' class="topic-cell-end"' : '';
        const topicTd = `<td data-label="Topic" rowspan="${group.length}"${topicCellClass}><span class="topic">${topicText}</span></td>`;
        return `<tr${finalTrClass}>${topicTd}${dateTd}${paperTd}${slidesTd}${notesTd}</tr>`;
      }

      // Otherwise (continuation rows), omit the topic cell completely.
      return `<tr${finalTrClass}>${dateTd}${paperTd}${slidesTd}${notesTd}</tr>`;
    }).join("");
  }

  render();
</script>

</body>
</html>

